# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n0_Dlr0oodTxQBHCZZ8L5AwIDMcoOZFX
"""

pip install tensorflow matplotlib seaborn scikit-learn

# CNN Image Classification Model for CODTECH Internship Task-3
# Built using TensorFlow/Keras for CIFAR-10 dataset

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns

# Set random seed for reproducibility
tf.random.set_seed(42)
np.random.seed(42)

class CNNImageClassifier:
    def __init__(self):
        self.model = None
        self.history = None
        self.class_names = ['airplane', 'automobile', 'bird', 'cat', 'deer',
                           'dog', 'frog', 'horse', 'ship', 'truck']

    def load_and_preprocess_data(self):
        """Load and preprocess CIFAR-10 dataset"""
        print("Loading CIFAR-10 dataset...")

        # Load CIFAR-10 data
        (x_train, y_train), (x_test, y_test) = keras.datasets.cifar10.load_data()

        # Normalize pixel values to [0, 1]
        x_train = x_train.astype('float32') / 255.0
        x_test = x_test.astype('float32') / 255.0

        # Convert labels to categorical one-hot encoding
        y_train = keras.utils.to_categorical(y_train, 10)
        y_test = keras.utils.to_categorical(y_test, 10)

        print(f"Training data shape: {x_train.shape}")
        print(f"Training labels shape: {y_train.shape}")
        print(f"Test data shape: {x_test.shape}")
        print(f"Test labels shape: {y_test.shape}")

        return (x_train, y_train), (x_test, y_test)

    def build_cnn_model(self):
        """Build CNN architecture"""
        print("Building CNN model...")

        model = keras.Sequential([
            # First Convolutional Block
            layers.Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)),
            layers.BatchNormalization(),
            layers.Conv2D(32, (3, 3), activation='relu'),
            layers.MaxPooling2D((2, 2)),
            layers.Dropout(0.25),

            # Second Convolutional Block
            layers.Conv2D(64, (3, 3), activation='relu'),
            layers.BatchNormalization(),
            layers.Conv2D(64, (3, 3), activation='relu'),
            layers.MaxPooling2D((2, 2)),
            layers.Dropout(0.25),

            # Third Convolutional Block
            layers.Conv2D(128, (3, 3), activation='relu'),
            layers.BatchNormalization(),
            layers.Dropout(0.25),

            # Flatten and Dense layers
            layers.Flatten(),
            layers.Dense(512, activation='relu'),
            layers.BatchNormalization(),
            layers.Dropout(0.5),
            layers.Dense(10, activation='softmax')  # 10 classes for CIFAR-10
        ])

        # Compile model
        model.compile(
            optimizer='adam',
            loss='categorical_crossentropy',
            metrics=['accuracy']
        )

        self.model = model
        return model

    def train_model(self, x_train, y_train, x_test, y_test, epochs=50, batch_size=32):
        """Train the CNN model"""
        print("Training CNN model...")

        # Data augmentation
        datagen = keras.preprocessing.image.ImageDataGenerator(
            rotation_range=15,
            width_shift_range=0.1,
            height_shift_range=0.1,
            horizontal_flip=True,
        )
        datagen.fit(x_train)

        # Callbacks
        callbacks = [
            keras.callbacks.EarlyStopping(patience=10, restore_best_weights=True),
            keras.callbacks.ReduceLROnPlateau(factor=0.5, patience=5)
        ]

        # Train model
        self.history = self.model.fit(
            datagen.flow(x_train, y_train, batch_size=batch_size),
            steps_per_epoch=len(x_train) // batch_size,
            epochs=epochs,
            validation_data=(x_test, y_test),
            callbacks=callbacks,
            verbose=1
        )

        return self.history

    def evaluate_model(self, x_test, y_test):
        """Evaluate model performance"""
        print("\nEvaluating model performance...")

        # Get predictions
        test_loss, test_accuracy = self.model.evaluate(x_test, y_test, verbose=0)
        y_pred = self.model.predict(x_test)
        y_pred_classes = np.argmax(y_pred, axis=1)
        y_true_classes = np.argmax(y_test, axis=1)

        print(f"Test Accuracy: {test_accuracy:.4f}")
        print(f"Test Loss: {test_loss:.4f}")

        # Classification report
        print("\nClassification Report:")
        print(classification_report(y_true_classes, y_pred_classes,
                                  target_names=self.class_names))

        return test_accuracy, test_loss, y_pred_classes, y_true_classes

    def plot_training_history(self):
        """Plot training history"""
        if self.history is None:
            print("No training history available. Train the model first.")
            return

        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))

        # Plot training & validation accuracy
        ax1.plot(self.history.history['accuracy'], label='Training Accuracy')
        ax1.plot(self.history.history['val_accuracy'], label='Validation Accuracy')
        ax1.set_title('Model Accuracy')
        ax1.set_xlabel('Epoch')
        ax1.set_ylabel('Accuracy')
        ax1.legend()
        ax1.grid(True)

        # Plot training & validation loss
        ax2.plot(self.history.history['loss'], label='Training Loss')
        ax2.plot(self.history.history['val_loss'], label='Validation Loss')
        ax2.set_title('Model Loss')
        ax2.set_xlabel('Epoch')
        ax2.set_ylabel('Loss')
        ax2.legend()
        ax2.grid(True)

        plt.tight_layout()
        plt.show()

    def plot_confusion_matrix(self, y_true, y_pred):
        """Plot confusion matrix"""
        cm = confusion_matrix(y_true, y_pred)

        plt.figure(figsize=(10, 8))
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                   xticklabels=self.class_names,
                   yticklabels=self.class_names)
        plt.title('Confusion Matrix')
        plt.xlabel('Predicted Label')
        plt.ylabel('True Label')
        plt.show()

    def predict_sample_images(self, x_test, y_test, num_samples=8):
        """Predict and display sample images"""
        # Select random samples
        indices = np.random.choice(len(x_test), num_samples, replace=False)

        fig, axes = plt.subplots(2, 4, figsize=(12, 6))
        axes = axes.ravel()

        for i, idx in enumerate(indices):
            # Get prediction
            prediction = self.model.predict(x_test[idx:idx+1])
            predicted_class = np.argmax(prediction)
            true_class = np.argmax(y_test[idx])
            confidence = np.max(prediction)

            # Display image
            axes[i].imshow(x_test[idx])
            axes[i].set_title(f'True: {self.class_names[true_class]}\n'
                            f'Pred: {self.class_names[predicted_class]}\n'
                            f'Conf: {confidence:.2f}')
            axes[i].axis('off')

        plt.tight_layout()
        plt.show()

    def save_model(self, filepath='cnn_cifar10_model.h5'):
        """Save the trained model"""
        if self.model is not None:
            self.model.save(filepath)
            print(f"Model saved to {filepath}")
        else:
            print("No model to save. Train the model first.")

def main():
    """Main execution function"""
    print("="*60)
    print("CODTECH INTERNSHIP - TASK 3")
    print("CNN IMAGE CLASSIFICATION MODEL")
    print("="*60)

    # Initialize classifier
    classifier = CNNImageClassifier()

    # Load and preprocess data
    (x_train, y_train), (x_test, y_test) = classifier.load_and_preprocess_data()

    # Build model
    model = classifier.build_cnn_model()

    # Display model architecture
    print("\nModel Architecture:")
    model.summary()

    # Train model
    print("\nStarting training...")
    history = classifier.train_model(x_train, y_train, x_test, y_test, epochs=25)

    # Evaluate model
    test_acc, test_loss, y_pred, y_true = classifier.evaluate_model(x_test, y_test)

    # Plot results
    print("\nGenerating visualizations...")
    classifier.plot_training_history()
    classifier.plot_confusion_matrix(y_true, y_pred)
    classifier.predict_sample_images(x_test, y_test)

    # Save model
    classifier.save_model()

    print("\n" + "="*60)
    print("MODEL TRAINING COMPLETE!")
    print(f"Final Test Accuracy: {test_acc:.4f}")
    print("="*60)

    return classifier

if __name__ == "__main__":
    # Run the complete pipeline
    trained_classifier = main()